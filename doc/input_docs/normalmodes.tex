\section{NORMALMODES}
\label{NORMALMODES}
\begin{ipifield}{}%
{Deals with the normal mode transformations, including the adjustment of bead masses to give the desired ring polymer normal mode frequencies if appropriate. Takes as arguments frequencies, of which different numbers must be specified and which are used to scale the normal mode frequencies in different ways depending on which 'mode' is specified.}%
{}%
{\ipiitem{transform}%
{Specifies whether to calculate the normal mode transform using a fast Fourier transform or a matrix multiplication. For small numbers of beads the matrix multiplication may be faster.}%
{default: `fft'; data type: string; options: `fft', `matrix'; }%
}
\begin{ipifield}{\hyperref[NMFREQUENCIES]{frequencies}}%
{Specifies normal mode frequencies for a (closed path) calculation}%
{dimension: frequency; default:  [ ] ; data type: float; }%
{\ipiitem{units}%
{The units the input data is given in.}%
{default: `automatic'; data type: string; }%
\ipiitem{shape}%
{The shape of the array.}%
{default:  (0,) ; data type: tuple; }%
\ipiitem{style}%
{Specifies the technique to be used to calculate the dynamical masses.
                                                'rpmd' simply assigns the bead masses the physical mass.
                                                'manual' sets all the normal mode frequencies except the centroid normal mode manually.
                                                'pa-cmd' takes an argument giving the frequency to set all the non-centroid normal modes to.
                                                'wmax-cmd' is similar to 'pa-cmd', except instead of taking one argument it takes two
                                                      ([wmax,wtarget]). The lowest-lying normal mode will be set to wtarget for a
                                                      free particle, and all the normal modes will coincide at frequency wmax. }%
{default: `rpmd'; data type: string; options: `pa-cmd', `wmax-cmd', `manual', `rpmd'; }%
\ipiitem{mode}%
{If 'mode' is 'manual', then the array is read from the content of 'cell' takes a 9-elements vector containing the cell matrix (row-major). If 'mode' is 'abcABC', then 'cell' takes an array of 6 floats, the first three being the length of the sides of the system parallelopiped, and the last three being the angles (in degrees) between those sides. Angle A corresponds to the angle between sides b and c, and so on for B and C. If mode is 'abc', then this is the same as for 'abcABC', but the cell is assumed to be orthorhombic. 'pdb' and 'chk' read the cell from a PDB or a checkpoint file, respectively.}%
{default: `manual'; data type: string; options: `manual', `file'; }%
}
\end{ipifield}
\begin{ipifield}{open\_paths}%
{Indices of the atmoms whose path should be opened (zero-based).}%
{default:  [ ] ; data type: integer; }%
{\ipiitem{shape}%
{The shape of the array.}%
{default:  (0,) ; data type: tuple; }%
\ipiitem{mode}%
{If 'mode' is 'manual', then the array is read from the content of 'cell' takes a 9-elements vector containing the cell matrix (row-major). If 'mode' is 'abcABC', then 'cell' takes an array of 6 floats, the first three being the length of the sides of the system parallelopiped, and the last three being the angles (in degrees) between those sides. Angle A corresponds to the angle between sides b and c, and so on for B and C. If mode is 'abc', then this is the same as for 'abcABC', but the cell is assumed to be orthorhombic. 'pdb' and 'chk' read the cell from a PDB or a checkpoint file, respectively.}%
{default: `manual'; data type: string; options: `manual', `file'; }%
}
\end{ipifield}
\end{ipifield}
