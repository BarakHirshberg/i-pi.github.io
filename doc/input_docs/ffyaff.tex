\section{FFYAFF}
\label{FFYAFF}
\begin{ipifield}{}%
{Uses a Yaff force field to compute the forces.}%
{}%
{\ipiitem{name}%
{Mandatory. The name by which the forcefield will be identified in the System forces section.}%
{data type: string; }%
\ipiitem{pbc}%
{Applies periodic boundary conditions to the atoms coordinates before passing them on to the driver code.}%
{default:  True ; data type: boolean; }%
}
\begin{ipifield}{latency}%
{The number of seconds the polling thread will wait between exhamining the list of requests.}%
{default:  0.01 ; data type: float; }%
{}
\end{ipifield}
\begin{ipifield}{yaffsys}%
{This gives the file name of the Yaff input system file.}%
{default: `system.chk'; data type: string; }%
{}
\end{ipifield}
\begin{ipifield}{parameters}%
{The parameters of the force field}%
{default:  \{ \} ; data type: dictionary; }%
{}
\end{ipifield}
\begin{ipifield}{activelist}%
{List with indexes of the atoms that this socket is taking care of.    Default: all (corresponding to -1)}%
{default: 
      [-1]; data type: integer; }%
{\ipiitem{shape}%
{The shape of the array.}%
{default:  (1,) ; data type: tuple; }%
\ipiitem{mode}%
{If 'mode' is 'manual', then the array is read from the content of 'cell' takes a 9-elements vector containing the cell matrix (row-major). If 'mode' is 'abcABC', then 'cell' takes an array of 6 floats, the first three being the length of the sides of the system parallelopiped, and the last three being the angles (in degrees) between those sides. Angle A corresponds to the angle between sides b and c, and so on for B and C. If mode is 'abc', then this is the same as for 'abcABC', but the cell is assumed to be orthorhombic. 'pdb' and 'chk' read the cell from a PDB or a checkpoint file, respectively.}%
{default: `manual'; data type: string; options: `manual', `file'; }%
}
\end{ipifield}
\begin{ipifield}{yafflog}%
{This gives the file name of the Yaff output log file.}%
{default: `yaff.log'; data type: string; }%
{}
\end{ipifield}
\begin{ipifield}{alpha\_scale}%
{This gives the alpha parameter in the Ewald summation based on the real-space cutoff: alpha = alpha\_scale / rcut. Higher values for this parameter imply a faster convergence of the reciprocal terms, but a slower convergence in real-space.}%
{default:  3.5 ; data type: float; }%
{}
\end{ipifield}
\begin{ipifield}{rcut}%
{This gives the real space cutoff used by all pair potentials in atomic units.}%
{default:  18.8972613392 ; data type: float; }%
{}
\end{ipifield}
\begin{ipifield}{gcut\_scale}%
{This gives the reciprocale space cutoff based on the alpha parameter: gcut = gcut\_scale * alpha. Higher values for this parameter imply a better convergence in the reciprocal space.}%
{default:  1.1 ; data type: float; }%
{}
\end{ipifield}
\begin{ipifield}{smooth\_ei}%
{This gives the flag for smooth truncations for the electrostatic interactions.}%
{default:  False ; data type: boolean; }%
{}
\end{ipifield}
\begin{ipifield}{yaffpara}%
{This gives the file name of the Yaff input parameter file.}%
{default: `parameters.txt'; data type: string; }%
{}
\end{ipifield}
\begin{ipifield}{skin}%
{This gives the skin parameter for the neighborlist.}%
{default:  0 ; data type: integer; }%
{}
\end{ipifield}
\begin{ipifield}{reci\_ei}%
{This gives the method to be used for the reciprocal contribution to the electrostatic interactions in the case of periodic systems. This must be one of 'ignore' or 'ewald'. The 'ewald' option is only supported for 3D periodic systems.}%
{default: `ewald'; data type: string; }%
{}
\end{ipifield}
\end{ipifield}
